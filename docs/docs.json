{"name":"mint-micromark","dependencies":[],"components":[{"description":null,"name":"Main","connects":[],"computed-properties":[{"type":null,"description":null,"name":"examples","source":"get examples {\n  [\n    {p, (e : Html.Event) { next { p: Dom.getValue(e.target) } }, []},\n    {h1, (e : Html.Event) { next { h1: Dom.getValue(e.target) } }, []},\n    {h2, (e : Html.Event) { next { h2: Dom.getValue(e.target) } }, []},\n    {h3, (e : Html.Event) { next { h3: Dom.getValue(e.target) } }, []},\n    {h4, (e : Html.Event) { next { h4: Dom.getValue(e.target) } }, []},\n    {h5, (e : Html.Event) { next { h5: Dom.getValue(e.target) } }, []},\n    {h6, (e : Html.Event) { next { h6: Dom.getValue(e.target) } }, []},\n    {frontmatter, (e : Html.Event) { next { frontmatter: Dom.getValue(e.target) } }, [Micromark.Extension::Frontmatter]},\n    {gfm, (e : Html.Event) { next { gfm: Dom.getValue(e.target) } }, [Micromark.Extension::Gfm]},\n    {gfmtable, (e : Html.Event) { next { gfmtable: Dom.getValue(e.target) } }, [Micromark.Extension::Gfm]},\n    {math1, (e : Html.Event) { next { math1: Dom.getValue(e.target) } }, [Micromark.Extension::Math]},\n    {mdx, (e : Html.Event) { next { mdx: Dom.getValue(e.target) } }, [Micromark.Extension::Mdx]}\n  ]\n}"}],"properties":[],"functions":[{"type":null,"description":null,"name":"render","source":"fun render {\n  <div::list>\n    for example of examples {\n      <div::example>\n        <div::content>\n          <Micromark.Component\n            content={example[0]}\n            extensions={example[2]}/>\n        </div>\n\n        <textarea::input onChange={example[1]}>\n          <{ example[0] }>\n        </textarea>\n      </div>\n    }\n  </div>\n}","arguments":[]}],"providers":[],"states":[{"type":null,"description":null,"default":"0","name":"count"},{"type":null,"description":null,"default":"\"This is *plain* markdown, **no extensions** enabled\\n\\n* list items\"","name":"p"},{"type":null,"description":null,"default":"\"# This is an H1\"","name":"h1"},{"type":null,"description":null,"default":"\"## This is an H2\"","name":"h2"},{"type":null,"description":null,"default":"\"### This is an H3\"","name":"h3"},{"type":null,"description":null,"default":"\"#### This is an H4\"","name":"h4"},{"type":null,"description":null,"default":"\"##### This is an H5\"","name":"h5"},{"type":null,"description":null,"default":"\"###### This is an H6\"","name":"h6"},{"type":null,"description":null,"default":"\"---\\na: b\\n---\\n# Using frontmatter doesn't matter\"","name":"frontmatter"},{"type":null,"description":null,"default":"\"~~GFM extension enabled~~\"","name":"gfm"},{"type":null,"description":null,"default":"\"|header|\\n|-|\\n|cell|\"","name":"gfmtable"},{"type":null,"description":null,"default":"\"Lift($L$) can be determined by Lift Coefficient ($C_L$) like the following equation.\\n$$\\nL = \\\\frac{1}{2} \\\\rho v^2 S C_L\\n$$\"","name":"math1"},{"type":null,"description":null,"default":"\"mdx extension\n  \n  a <b /> c {1 + 1} d\n  \"","name":"mdx"}]},{"description":null,"name":"Micromark.Component","connects":[],"computed-properties":[{"type":null,"description":null,"name":"markdownBodyClass","source":"get markdownBodyClass {\n  if enableCss {\n    \"markdown-body\"\n  } else {\n    \"\"\n  }\n}"}],"properties":[{"default":"\"\"","type":"String","description":null,"name":"content"},{"default":"false","type":"Bool","description":null,"name":"allowDangerousHtml"},{"default":"false","type":"Bool","description":null,"name":"allowDangerousProtocol"},{"default":"\"\"","type":"String","description":null,"name":"defaultLineEnding"},{"default":"[Micromark.Extension::Gfm]","type":"Array(Micromark.Extension)","description":null,"name":"extensions"},{"default":"true","type":"Bool","description":null,"name":"enableCss"}],"functions":[{"type":null,"description":null,"name":"componentDidMount","source":"fun componentDidMount {\n  if enableCss && Array.contains(extensions, Micromark.Extension::Gfm) {\n    Micromark.GithubCSS.load()\n  }\n\n  if enableCss && Array.contains(extensions, Micromark.Extension::Math) {\n    Micromark.KatexCSS.load()\n  }\n\n  let micromark =\n    await Micromark.load(extensions, allowDangerousHtml, allowDangerousProtocol, defaultLineEnding)\n\n  next { micromark: Maybe::Just(micromark) }\n}","arguments":[]},{"type":null,"description":null,"name":"render","source":"fun render {\n  <>\n    case micromark {\n      => <></>\n\n      Maybe::Just(micromark) =>\n        {\n          let html =\n            micromark(content)\n\n          <div\n            class={markdownBodyClass}\n            dangerouslySetInnerHTML={`{__html: #{html}}`}/>\n        }\n    }\n  </>\n}","arguments":[]}],"providers":[],"states":[{"type":"Maybe(Function(String, String))","description":null,"default":"Maybe::Nothing","name":"micromark"}]},{"description":null,"name":"Micromark.GithubCSS","connects":[],"computed-properties":[],"properties":[],"functions":[{"type":null,"description":null,"name":"load","source":"fun load {\n  if loaded {\n    next { }\n  } else {\n    next { loaded: true }\n  }\n}","arguments":[]},{"type":"Html","description":null,"name":"render","source":"fun render : Html {\n  if loaded {\n    <Html.Portals.Head>\n      <link\n        rel=\"stylesheet\"\n        href=\"#{@asset(../assets/github-markdown.min.css)}\"/>\n    </Html.Portals.Head>\n  } else {\n    <></>\n  }\n}","arguments":[]}],"providers":[],"states":[{"type":"Bool","description":null,"default":"false","name":"loaded"}]},{"description":null,"name":"Micromark.KatexCSS","connects":[],"computed-properties":[],"properties":[],"functions":[{"type":null,"description":null,"name":"load","source":"fun load {\n  if loaded {\n    next { }\n  } else {\n    next { loaded: true }\n  }\n}","arguments":[]},{"type":"Html","description":null,"name":"render","source":"fun render : Html {\n  if loaded {\n    <Html.Portals.Head>\n      <link\n        rel=\"stylesheet\"\n        href=\"#{@asset(../assets/katex.min.css)}\"/>\n    </Html.Portals.Head>\n  } else {\n    <></>\n  }\n}","arguments":[]}],"providers":[],"states":[{"type":"Bool","description":null,"default":"false","name":"loaded"}]}],"stores":[],"modules":[{"description":null,"name":"Micromark","functions":[{"type":"Tuple(String, String)","description":"<p>Maps extension names to their respective named exports for syntax and html</p>\n","name":"extensionImports","source":"/* Maps extension names to their respective named exports for syntax and html */\nfun extensionImports (extension : Micromark.Extension) : Tuple(String, String) {\n  case extension {\n    Micromark.Extension::Directive => {\"directive\", \"directiveHtml\"}\n    Micromark.Extension::Frontmatter => {\"frontmatter\", \"frontmatterHtml\"}\n    Micromark.Extension::Gfm => {\"gfm\", \"gfmHtml\"}\n    Micromark.Extension::Math => {\"math\", \"mathHtml\"}\n    Micromark.Extension::Mdx => {\"mdx\", \"mdxHtml\"}\n  }\n}","arguments":[{"type":"Micromark.Extension","name":"extension"}]},{"type":"String","description":"<p>Maps extension to their asset paths</p>\n","name":"extensionPath","source":"/* Maps extension to their asset paths */\nfun extensionPath (extension : Micromark.Extension) : String {\n  case extension {\n    Micromark.Extension::Directive => DIRECTIVE\n    Micromark.Extension::Frontmatter => FRONTMATTER\n    Micromark.Extension::Gfm => GFM\n    Micromark.Extension::Math => MATH\n    Micromark.Extension::Mdx => MDX\n  }\n}","arguments":[{"type":"Micromark.Extension","name":"extension"}]},{"type":"Promise(Function(String, String))","description":"<p>Loads Micromark with the specified extensions.</p>\n","name":"load","source":"/* Loads Micromark with the specified extensions. */\nfun load (\n  extensions : Array(Micromark.Extension) = [],\n  allowDangerousHtml : Bool = false,\n  allowDangerousProtocol : Bool = false,\n  defaultLineEnding : String = \"\"\n) : Promise(Function(String, String)) {\n  let micromark =\n    await `import(#{MICROMARK}).then(m => m.micromark)`\n\n  let loaders =\n    Array.map(extensions, loadExtension)\n\n  let loaded =\n    await `Promise.all(#{loaders})` as Array(Tuple(syntax, html))\n\n  let syntax =\n    Array.map(loaded, (i : Tuple(syntax, html)) { i[0] })\n\n  let html =\n    Array.map(loaded, (i : Tuple(syntax, html)) { i[1] })\n\n  (markdown : String) : String {\n    `\n      (() => {\n        try {\n          const $md = #{micromark}(#{markdown}, {\n            extensions: #{syntax},\n            htmlExtensions: #{html},\n            allowDangerousHtml: #{allowDangerousHtml},\n            allowDangerousProtocol: #{allowDangerousProtocol},\n            defaultLineEnding: #{defaultLineEnding}\n          })\n\n          return $md\n        } catch($e) {\n          return $e.message\n        }\n      })()\n      `\n  }\n}","arguments":[{"type":"Array(Micromark.Extension)","name":"extensions"},{"type":"Bool","name":"allowDangerousHtml"},{"type":"Bool","name":"allowDangerousProtocol"},{"type":"String","name":"defaultLineEnding"}]},{"type":"Tuple(syntax, html)","description":"<p>Load an individual extension</p>\n","name":"loadExtension","source":"/* Load an individual extension */\nfun loadExtension (extension : Micromark.Extension) : Tuple(syntax, html) {\n  let path =\n    extensionPath(extension)\n\n  let imports =\n    extensionImports(extension)\n\n  let syntax =\n    imports[0]\n\n  let html =\n    imports[1]\n\n  `\n    import(#{path}).then(m => {\n      const syntax = m[#{syntax}] ? m[#{syntax}]() : null\n      const html = m[#{html}] ? m[#{html}]() : null\n\n      return [syntax, html]\n    })\n    `\n}","arguments":[{"type":"Micromark.Extension","name":"extension"}]}]}],"providers":[],"records":[],"enums":[{"description":null,"name":"Micromark.Extension","parameters":[],"options":[{"description":null,"name":"Directive","parameters":[]},{"description":null,"name":"Frontmatter","parameters":[]},{"description":null,"name":"Gfm","parameters":[]},{"description":null,"name":"Math","parameters":[]},{"description":null,"name":"Mdx","parameters":[]}]}]}